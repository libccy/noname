/// <reference types="noname-typings" />
type logAudio = (...args: any[]) => AudioInfo;
type AudioInfo = AudioInfo[] | string | number | boolean;
type SkillInfo = {
    audio?: AudioInfo;
    audioname?: string[];
    audioname2?: {
        [playerName: string]: AudioInfo;
    };
    logAudio?: logAudio;
    logAudio2?: {
        [playerName: string]: logAudio;
    };
};
type FormatedPlayer = {
    name: string;
    sex: Sex;
    name1?: string;
    name2?: string;
    tempname: string[];
    skin: {
        name?: string;
    };
};
type TextMap = {
    name: string;
    file: string;
    text: string | undefined;
    type: string;
};
export declare class Audio {
    #private;
    /**
     * 根据skill中的audio,audioname,audioname2和player来获取技能台词列表及其对应的源文件名
     * @param skill 技能名
     * @param player 角色/角色名
     * @param info 使用指定的skillInfo/audioInfo
     * @param args
     */
    static skill({ skill, player, info, args }: {
        skill: string;
        player: Player | string;
        info?: AudioInfo | SkillInfo;
        args?: any[];
    }): Audio;
    /**
     * 获取角色死亡时能播放的所有阵亡台词列表及其对应的源文件名
     * @param player 角色/角色名
     * @param info 使用指定的audioInfo
     * @param args
     */
    static die({ player, info, args }: {
        player: Player | string;
        info?: AudioInfo;
        args?: any[];
    }): Audio;
    static formatPlayer(player: Player | string): FormatedPlayer;
    static toFile(list: TextMap[]): string[];
    static toText(list: TextMap[]): string[];
    get name(): string;
    get type(): string;
    get audioList(): TextMap[];
    get fileList(): string[];
    get textList(): string[];
    initAudioList(): void;
    constructor(audio: AudioBase, args?: any[], history?: string[]);
    getReferenceAudio(name: string, info?: any): TextMap[];
    checkHistory(): boolean;
    parseAudio(name: string, audioInfo: AudioInfo): TextMap[];
}
interface AudioBase {
    type: string;
    name: string;
    isExist: (name: string) => boolean;
    defaultPath: string;
    defaultInfo: AudioInfo;
    useCache: boolean;
    getCacheKey: () => string;
    getAudioInfo: (useDefaultInfo: boolean, args?: any[]) => AudioInfo;
    getReferenceAudio: (name: string, info?: AudioInfo) => AudioBase;
    textMap: (path: string, ext: string, name: string) => TextMap;
    textMapWithIndex: (path: string, ext: string, index?: number) => TextMap;
}
export {};
